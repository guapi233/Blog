# 打家劫舍

[题目编号-198](https://leetcode-cn.com/problems/house-robber/)



## 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

 

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 400`



## 解题思路

### 二维DP

因为存在**不同房屋**以及**偷亦不偷**两种状态，所以需要创建二维数据结构来缓存中间变量

* 如果不偷当前的房子，则该位置的状态为**不偷上一个房子或偷上一个房子的最大值**
* 如果偷当前的房子，则该位置的状态为**不偷上一个房子 + 当前值**

最后去除缓存结构中的最大值即可



### 一维DP

一维是在二维上进行优化得出的，思考如何去维的关键是如果将**偷亦不偷**这个状态以另一种形式存储下来，

* 如果不偷当前的房子，状态为**上一个房子的累积值**
* 如果偷当前的房子，状态为**上上个房子 + 当前值**
* 比较这两种情况，将最大的值记录在当前位置

算是一种贪心的思想，将每一步最优的情况记录下来，最后的结果就是最优的。