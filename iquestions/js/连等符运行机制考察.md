# 连等符运行机制考察

* 引用赋值考察
* 连等符运行机制考察



## 题目

说出以下代码的执行结果并解释为什么：

```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };

console.log(a.x);
console.log(b.x);
```



## 答案

```js
console.log(a.x); // undefined
console.log(b.x); // { n: 2 }
```

这道题最令人疑惑的是`a.x = a = { n: 2 };`这一句代码，考察的知识点也很少见（主要是连等符很少用）。

首先，连等符是从右向左执行，也就是上面的代码可以转化为（🤔?）：

```js
a = { n: 2 };
a.x = a;
```

但是如果你真的将`a.x = a = { n: 2 };`拆解成上面两句代码来执行，就会发现执行结果和答案不一样了：

```js
var a = { n: 1 };
var b = a;
a = { n: 2 };
a.x = a;

console.log(a.x); // { n: 2 }
console.log(b.x); // undefined
```

可能这才是你最开始期望的结果，那我们先来看看拆解开来的这段代码是如何运行的：

1. 首先在内存中创建`{ n: 1 }`，并让变量`a`指向它；

2. 因为引用赋值的原因，并不会创建一个新的`{ n: 1 }`赋值给变量`b`，而是将`a`指向的`{ n: 1}`赋值给`b`。现在，`a`和`b`指向同一个对象；

3. 在内存中创建`{ n: 2 }`，并让变量`a`指向它。现在，内存中有两个对象，`a`指向`{ n: 2 }`，`b`指向`{ n: 1 }`；

4. 通过变量`a`为对象`{ n: 2 }`添加一个`x`属性，并将它的值设为`a`指向的`{ n: 2 }`（先获取到`{ n: 2 }`，再将它作为自身的属性）;

5. 打印结果，现在`a`指向的对象为`{ n: 2, x: { n: 2 } }`，故`a.x`为`{ n: 2 }`。 `b`指向的对象为`{ n: 1 }`，故`b.x`为`undefined`。

但是，如果使用连等符来执行操作的话，答案就不一样了，这其实是因为连等符的一条运行机制：

**在连等开始之前程序会把所有引用都保存下来，连等过程中，引用不会发生变化，而是等整条语句执行完毕后，一起发生改变。**

根据这条机制，我们再来看看这道面试题的执行过程：

1. 首先在内存中创建`{ n: 1 }`，并让变量`a`指向它；

2. 因为引用赋值的原因，并不会创建一个新的`{ n: 1 }`赋值给变量`b`，而是将`a`指向的`{ n: 1}`赋值给`b`。现在，`a`和`b`指向同一个对象；

3. 在内存中创建`{ n: 2 }`，并让变量`a`指向它，**但是由于连等语句还未结束，所以变量`a`仍然指向`{ n: 1 }`**。再通过变量`a`为**对象`{ n: 1 }`**添加一个`x`属性，值为`{ n: 2 }`；
4. **连等语句结束，变量`a`指向`{ n: 2 }`**；

5. 打印结果，现在`a`指向的对象为`{ n: 2 }`，故`a.x`为`undefined`。 `b`指向的对象为`{ n: 1, x: { n: 2 }  }`，故`b.x`为`{ n: 2 }`。



## 答案修正

1. 在上面，我提到了`a.x = a = { n: 2 };`可以拆分为`a = { n: 2 }, b = a`，其实这句话是错误的，虽然从结果上来看没什么问题，但其实更准确的拆分结果为`a = { n: 2 }, b = { n: 2 }`。这是因为我错误得将连等运算符的执行过程`1 = 2 = 3`理解成了`2 = 3, 1 = 2`，而其实它正确的执行顺序应该为`2 = 3, 1 = 3`。

   下面的代码解释了这个错误：

   ```js
   var a = {};
   Object.defineProperty(a, "name", {
     get() {
       return "1";
     },
   });
   // a.name为只读，只会返回"1"
   
   var b = {};
   b.name = a.name = "2";
   // 如果连等的执行顺序为2=3,1=2，那么a和b的name都会为1
   
   console.log(b.name, a.name); // 2 1
   ```

   