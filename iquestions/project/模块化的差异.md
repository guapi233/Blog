# 模块化的差异

简述AMD、CMD、COMMONJS、ESMODULE的差异



## 涉及知识点

* 前端模块化



## 解题思路

### 依赖前置与依赖就近

AMD提倡**依赖前置**，即需要引入的模块已经做好前置准备，如以下代码：

```js
define([模块A, 模块B], function (A, B) {
    // 第三模块内代码
})；
```

上面的代码中，模块A和模块B已经在第三个模块之前前置了，如果想到更改模块A的依赖，只需要更改前方的引用即可，而无需修改第三个模块内的代码。

换句话说，第三个模块是一个相对独立的模块，内部的引用是由外部传进来的，不会造成额外的引用耦合，需要什么模块就传入什么模块。



CMD、COMMONJS、ESMODULE这三个规范提倡**依赖就近**，即需要在模块内填写需要引入模块的引用，这种规范会造成一定的引用耦合，不过优点就是很明显的可以知道该模块引用了哪些其他模块。



### 动态引入与静态引入

ESMODULE使用的是静态引入，即引入语句不能处于任何逻辑语句中，也就是下面这段代码再ESMODULE中是不被允许的：

```js
if (true) {
    import A from "../a.js";
} else {
    import B from "../b.js";
}
```

这么做好处就是可以对文件进行一个预处理工作，因为引入语句本身不会存在不确定性，所以能在运行时之前构建出文件之间的引用关系，事实上webpack底层也确实进行了相关的工作。



而其他的三种规范支持的是动态引入，即引入语句的执行结果是最先存在于运行时环境的，也就是说类似于上面的代码在这三种规范中是被允许的。

这么做确实从语言层面上提高了模块的灵活性，不过也为模块引用带来了一定不确定性，无法像ESMODULE那样对模块进行相应的预处理工作。