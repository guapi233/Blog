# 浏览器内在学习


## Chrome架构：仅仅打开了1个页面，为什么有4个进程？

### 进程和线程

多线程可以并行处理任务，但是**线程是不能单独存在的，它是由进程来启动和管理的**。那什么又是进程呢？

进程就是一个程序的运行实例，详细解释就是，启动一个程序的时候，操作系统会为该程序创建**一块内存，用来存放代码运行中的数据和一个执行任务的主线程**，我们把这样的一个运行环境叫进程。

**进程和线程的关系为：**

1. 进程中的任意一条线程执行出错，都会导致整个进程的崩溃
2. 线程之间共享同一进程中的数据
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存（泄漏的也会）
4. 进程之间相互隔离



### 单进程浏览器

**图在仓库的images下**

**单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里**，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。其实早在 2007 年之前，市面上浏览器都是单进程的。

单线程浏览器常见的问题有：

1. 不稳定，单一线程的死亡都会导致浏览器的暴毙
2. 不流畅，只要有一个页面中出了死循环或长时间任务，浏览器就未响应了
3. 不安全，这主要是因为单进程浏览器无法做沙箱（浏览器主线程需要访问系统权限），导致会受到恶意插件的攻击



### 多进程浏览器

针对单进程浏览器的问题，多进程有如下改进：

1. 针对不稳定，由于进程之间是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面。（一个页面一个渲染进程，但如果是**同一站点**的不同页面，它们共享一个渲染进程，当然，死也是一块死）
2. 针对不流畅，因为JavaScript也是运行在渲染进程中的，所以即使有一个页面死循环了，阻塞了渲染进程，影响到的也只是当前的页面
3. 针对不安全，上面也提到了单进程浏览器无法做沙箱的原因，到这里就完美解决了，对存在主要安全问题的进程（渲染进程和插件进程）做沙箱，这样里面做的工作就怎么也不会突破到沙箱外面，就操作系统产生影响了



### 目前的多进程浏览器

目前的多进程浏览器又从主进程中将**网络进程**和**GPU进程**抽离出来了

- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU 进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。



### 多进程浏览器目前存在的问题 & 正在实施的解决方案

**问题**

1. 高额的资源消耗
2. 浏览器日渐复杂，功能模块耦合度太高，扩展性差

**解决方案**

1. 提供灵活的弹性架构，当资源受限时，将相关的服务整合到一个进程中，从而节省内存
2. 对目前的浏览器结构进行拆分，实施**SOA(Services Oriented Architecture)**面向服务的架构，把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，从而**构建一个更内聚、松耦合、易于维护和扩展的系统**，更好实现 Chrome 简单、稳定、高速、安全的目标。





## TCP协议：如何保证页面文件能被完整送达浏览器？

UDP大体的概念这里就不多赘述了，直接上TCP如何确保数据完整性的。



### TCP报文格式

 ![图片加载中](http://img.blog.csdn.net/20170227111849763?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTWFyeTE5OTIwNDEw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

* 源端口：发送端的端口号

* 目的端口：接收端的端口号

* 序号：如果是初始报文，则为随机数，后面逐渐递增

* 确认序号：上一个接收报文的序号 + 1

* 标志位：

  ![img](https://img2018.cnblogs.com/blog/1454483/201906/1454483-20190629132816032-2043402666.png)



### 三次握手建立逻辑连接

![img](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

1. 客户端向服务端发送建立连接请求`seq=x, SYN=1 `
2. 服务端向客户端响应`ack=x+1, seq=y, ACK=1, SYN=1`
3. 客服端了解可以建立连接后，还需向服务端回一封确认报文`ack=y+1, seq=x+1, ACK=1`

**为什么是3次？为什么不能是2次？**

3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。说大白话就是双方都要确定**自己能接收到对方的消息**，以及**自己的消息对方能接收到**



### 四次挥手

![img](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

1. 客户端想断开了，于是向服务端发送报文`FIN=1, seq=u`
2. 服务端知道了，回复报文`ACK=1, seq=v, ack=u + 1`，表示可以，但是我这里可能还有点报文没发完，稍等一下我再叫你
3. 服务端确认自己这里已经没有待发送的报文后，向客户端发送断开报文`FIN=1, seq=w, ack=u+1`
4. 客户端也知道了，回复一下服务端表示自己知道了`ACK=1, seq=u+1, ack=w+1`，这下双方都知道对面要断开了，通话到此结束（省略了TIME-WAIT阶段）



### 其他

TCP还运用了拥塞**避免算法(慢启动)、计时器、重传**等手段来保证报文完整的传输。

