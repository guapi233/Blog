# 知识点速览

### Object.defineProperty

默认的三个配置项全是`false`，即

* 不可配置
* 不可修改
* 不可遍历





### Vue中的抽象组件

通过设置`abstract`为`true`开启抽象组件。

抽象组件的特点就是不会渲染真实的DOM，比如`<transition>`、`<transition-group>`、`<keep-alive>`这些不会在页面上生成多余组件，但是会产生功能效果的组件。

另外，抽象组件**不会**成为被包裹组件的父组件，在源码阶段，Vue会在向上寻找时过滤掉带`abstract`标记的组件。

```vue
// 实例代码：实现一个debounce组件
<script>
import {get, debounce, set} from 'loadsh';

export default {
    name: 'debounce',

    abstract: true, //标记为抽象组件

    render() {
        let vnode = this.$slots.default[0]; // 子组件的vnode
        if (vnode) {
            let event = get(vnode, `data.on.click`); // 子组件绑定的click事件
            if (typeof event === 'function') {
                set(vnode, `data.on.click`, debounce(event, 1000));
            }
        }
        return vnode;
    }
};
</script>
```





### 新奇的Vue写法

通过学源码了解到的

```js
new Vue({
  el: "#a",
  // 此处的vm中prop、inject等上层数据已初始化完毕
  data(vm) {
    console.log(vm, "开始初始化data的vm");
    return {
      a: "哈哈",
    };
  },
  beforeCreate() {
    // 因为beforeCreate在initData之前执行，所以在这里向$options.data绑定属性也会被响应式
    // 但是如果向下方这样写就会覆盖原来已经merge好的data，也就是上方的a就访问不到了
    this.$options.data = { $aa: "!!" };
  },
  // 数组格式的生命周期
  created: [
    () => {
      console.log("??");
    },
    () => {
      console.log("!!!");
    },
  ],
});
```







### Vue errorHandler &  errorCaptured

`errorHandler` 是2.2.0+版本提供的全局错误处理方法，默认为`undefined`时，Vue会通过`console.err`来打印错误信息，避免整个程序直接崩溃。（该方法在2.4.0 & 2.6.0 有部分更新，具体参考[API — Vue.js](https://cn.vuejs.org/v2/api/#errorHandler)）

`errorCaptured`是2.5.0+版本提供的用于捕获子孙组件的错误，是一种新增的**生命周期**，并且该钩子也可以与`errorHandler`产生互动，具体参考[API — Vue.js](https://cn.vuejs.org/v2/api/#errorCaptured)。





### git关闭忽略文件名称大小写配置

在当前项目中，早先创建并已经push到远程的文件及文件夹，将名称大小写更改后，git无法检测出更改。
出现这种情况的原因是，git默认配置为忽略大小写，因此无法正确检测大小写的更改。
那么，解决办法是，在当前项目中，运行`git config core.ignorecase false`，关闭git忽略大小写配置，即可检测到大小写名称更改。





### v-for中的key

可以这样简单地理解，无：key属性时，状态默认绑定的是位置；有：key属性时，状态根据key的属性值绑定到了相应的数组元素。

[通俗解释](https://www.zhihu.com/question/61064119/answer/766607894)





### Vue中的watch监听引用对象

> 注意：在变更 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变更之前值的副本。

**watch高级用法**

* `deep`：是否深度监听
* `immediate`：是否在第一次初始化时立即执行

`vm.$watch` 返回一个取消观察函数，用来停止触发回调：

```js
var unwatch = vm.$watch('a', cb)
// 之后取消观察
unwatch()
```

注意在带有 `immediate` 选项时，你不能在第一次回调时取消侦听给定的 property





### 为什么Vue中不推荐v-for和v-if一起使用

因为`v-for`的优先级较高，会导致现将元素渲染出来，在做`v-if`判断，会造成不必要的消耗，要么大家都不出来，要么就使用`computed`筛选后在做遍历。





### webp

是谷歌推出的适合于 Web 使用的图像格式，在保持同样质量的情况下，可比 JPG 减小 40% 的体积。





### path.join & path.resolve

* path.join():方法使用平台特定的分隔符把全部给定的 path 片段**连接**到一起，并**规范化**生成的路径
* path.resolve:方法会把一个路径或路径片段的序列解析为一个**绝对路径**





### 元素的offsetTop属性

表示元素到`offsetParent`顶部的距离

 **offsetParent**：距离元素最近的一个具有定位的祖宗元素（`relative`，`absolute`，`fixed`），若祖宗都不符合条件，`offsetParent`为`body`。





### 为什么Vue不要挂载到html和body上

为什么不能挂载到`html`或者`body`上呢，其实这是因为：`$mount`方法执行后，会直接替换挂载节点上面的内容，如果直接挂载`html`或者`body`上，很有可能会丢失掉一些东西，比如：`meta`，`link`或者`script`等。





### 分享页面至QQ

```http
http://connect.qq.com/widget/shareqq/index.html?url=你的分享网址&sharesource=qzone&title=你的分享标题&pics=你的分享图片地址&summary=你的分享描述&desc=你的分享简述
```





### padding、margin、position百分比取值

`padding、margin`的百分比取值是按照包含对象的**宽度**来计算的，而`position`的百分比取值是按照包含对象**横轴对应宽度，纵轴对应高度**来计算的。

这是因为，通常我们认为正常文档流下的包含块应该具有能够完全包裹住内容子元素（包括外边距）的高度，如果子元素的`padding、margin`按照包含元素的**高度**来计算，就会产生无限循环：

* 子元素`margin-top`加**30%**
* 因子元素高度变化，父元素高度增加
* 因父元素高度变化，子元素`margin-top`的**30%**取值增加
* 因......

而`position`因为已经脱离文档流，所以完全不需要考虑这些。





### 浏览器解析CSS选择器的顺序

**从右向左**，这是因为这样做可以快速筛选掉不合规则的选择器，例如`#main .container .title`：

* 如果**从左向右**，先找到有`#main`标识的元素，然后是`.container`，最后寻找其中包含的所有`.title`，如果`.title`不存在，那么这三次寻找就算是做了无用功
* 如果**从右向左**，先查找具有`.title`标识的元素，如果存在就检测它们的父级标识，而不存在挂有`.title`标识的话就直接中断后面的查找，相当于最少一次就可以过滤掉错误的选择器。





### 事件委托

事件委托利用了**事件冒泡**，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。





### mongoose的坑

* 如果不使用`async/await`，一定要传回调函数，否则操作不会执行（比如更新操作不会更新）。





### 消除Vue中TS对外部库类型的警报

在`shims-vue.d.ts`中添加`declare module "*";`





### setTimeout和setInterval的返回值

返回的是一个唯一的数值，浏览器通过该数值找到安装的指定定时器，同时`clearTimeout/clearInterval`会根据该值关闭定时器，但是不会清空保存这个数值的变量。

```js
let a = setTimeout(()=>{}, 1000); // a: 3688（唯一数值）
clearTimeout(a); // 定时器被关闭
console.log(a); // 3688
```

PS：上面的内容为浏览器中的行为，Node中的实现细节有所不同，在Node中，用一个对象保管定时器信息，关闭定时器后也不会清空保存这个对象的变量。





### clientHeight、offsetHeight、scrollHeight

* `clientHeight`包括元素的`content`、`padding`
* `offsetHeight`包括元素的`content`、`padding`、`border`
* `scrollHeight`为内容元素的高度，所以只包括元素的`content`





### CSS 中英文换行

1. `word-break: break-all;`：只对英文起作用，以字母作为换行依据
2. `word-wrap: break-word;` ：只对英文起作用，以单词作为换行依据
3. `white-space: pre-wrap;`：只对中文起作用，强制换行
4. `white-space: nowrap;` ：强制不换行，都起作用
5. `white-space: nowrap; overflow:hidden; text-overflow:ellipsis;`：不换行，超出部分隐藏且以省略号形式出现（部分浏览器支持） 





### visibility: hidden 和 opacity: 0 的区别

前者无法触发身上绑定的事件，同时也无法施加过渡效果。而后者全部可以。



### CSS伪类hover与伪元素before/after一起用

```CSS
.box:hover:after 
```

伪元素由`::`变为`:`。





### 组件式开发样式编写须知

1. 慎用`scoped`，尽可能在组件最外层包裹**唯一**类名
2. 尽可能得不要在父组件中使用**标签选择器**，很可能会影响到其他子组件





### line-height 对布局的影响

行高会决定`inline`以及`inline-block`等类似行内元素在父元素中的垂直排布位置，如果父元素的行高大于当前行内元素的高度，就会导致子元素的下坠现象，反之亦然，并且这往往**不能通过开发者工具明显的看到**。所以谨慎设置元素的行高，特别是内部很可能会出现行内元素时。





### git 清空工作区和暂存区

1. 还没进行 `add` 和 `commit` 操作：

   ```shell
   git checkout [路径]
   ```

2. 上面只能清空修改的文件，但是对于**新建的文件和文件夹**无法清空，必须使用下面的命令：

   ```shell
   git clean -f
   ```

3. 已经 `add` 了，使用：

   ```
   git reset .
   ```

4. 已经`commit`了，参考下面的`git reset`用法进行回退





### git reset

用于回退至某次提交，分别有三个参数：

* `hard`：清空当前所有区域的修改，完全回到某次提交时 
* `soft`：保留当前的`git add`和工作区未`add`的代码，回到某次提交
* `mixed（default）`：撤销当前的`add`到工作区，保留工作区未`add`的代码，回到某次提交





### 退出 git log

英文状态下按`q`。





### git revert

用一个新的`commit`覆盖原本的`commit`，用于退回某一次提交的操作内容（包括工作区和缓冲区），且被退回内容之后的修改内容不受影响。





### document.documentElement & document.body

在页面中包含`!DOCTYPE`标识时使用前者，否则使用后者。





### 在shell中选择内容

如果这么做，会中止正在执行的脚本。

按`ctrl + c`取消选择可继续执行脚本。





### class——super

* `super`在普通方法中作为对象使用时，表示父类的实例对象
* `super`在静态方法中作为对象使用时，表示父类本身





### MongoDB未查到的返回值

* `findOne`：为`null`，不是空对象
* `find`：是个空数组





### windows 查看端口占用情况

```shell
netstat -ano | findstr "端口号"
```





### TypeScript 中的类型断言 as

- 要理解好类型断言，其实就深刻理解一句话：**你会比TypeScript更了解某个值的详细信息** 。
- 类型断言，断言 断言，顾名思义，我断定怎么怎么样，代入这句话里就是，我断定这个类型是什么。当然这是我们主观上的思维逻辑，程序并不认可，所以我们需要告诉程序：**“相信我，我知道自己在干什么”** 。





### 自定义组件对外开放事件监听

默认情况下，我们是无法在自定义组件上监听事件的，通常我们会通过两种方式来解决：

* 在自定义组件身上使用`@事件.native`来监听原生事件
* 在自定义组件内部对相应事件做监听，并向上传递给父组件

这里提供第三种方法，在自定义组件内部添加`v-on="$listeners"`，将事件监听权限对外开放，这样就可以直接在父组件中对该组件进行事件监听了。

**补充**

除了对外开放事件监听，还有属性接收，比如我们需要对一个输入框进行封装，那么肯定要接收一个`value`属性作为输入框的`value`，如果没有其他用途，那么这个`value`的声明会显得非常冗余，因为需要父组件声明——父组件传给子组件——子组件声明——子组件传给输入框。

Vue在**2.4.0版本**除了推出`$listeners`之外，还有一个`$attrs`，它的作用如下：

> 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (`class` 和 `style` 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (`class` 和 `style` 除外)，并且可以通过 `v-bind="$attrs"` 传入内部组件——在创建高级别的组件时非常有用。

**二次补充——inheritAttrs**

> 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 `inheritAttrs` 到 `false`，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property `$attrs` 可以让这些 attribute 生效，且可以通过 `v-bind` 显性的绑定到非根元素上。





### 箭头函数没有原型

如题，箭头函数没有原型，没有`arguments`，没有`this`，且无法通过其他手段修改`this`，也无法作为构造函数。





### window.top & window.self

分别用来标记最顶层的浏览器窗口和当前的浏览器窗口。

**另外window.top不可覆盖，不能当全局变量使用**。





### Nuxt.js中 asyncData 与 data 的区别

**asyncData** 是在 vue 页面创建期间调用，用于给页面变量进行赋值的数据。

**目前的**理解是，提供了一个**可以通过`async/await`阻塞的组件加载钩子**，它和`beforeCreate`钩子的位置差不多，大概都在组件实例形成之前执行，且都无法访问`this`，但是`beforeCreate`无法通过`async/await`方式阻塞组件加载（如果强行阻塞很可能会导致后面的钩子先于 beforeCreate 执行）。

**实际应用场景**：

* asyncData可以通过阻塞的方式，将异步数据加载完毕后才渲染组件
* 这样做的好处是可以首屏渲染完整的页面，便于SEO
* 缺点也很明显，会延长白屏时间





### CSSStyleDeclaration.setProperty()

- `propertyName` 是一个 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString) ，代表被更改的CSS属性。
- `value`可选，是一个 `DOMString`，含有新的属性值。如果没有指定, 则当作空字符串。
  - 注意: *value* 不能包含 `"!important"` --那个应该使用 *priority* 参数.
- *priority*可选 是一个 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString) 允许设置 "important" CSS 优先级。如果没有指定, 则当作空字符串。



和`DOM.style.xxx = xxx `没太大区别，不过该方法可以修改声明的CSS变量。





### CSS变量

CSS原生也支持声明变量：

```CSS
:root {
   /* 通过双横线来声明 */
   --percentage: 0%;
}
```

通过`var(--percentage)`来读取，同时CSS变量也存在作用域，优先级最高的选择器之中的变量优先级最高，因此一般全局变量都声明在`:root`选择器中。

`var()`还有第二个参数，效果为：如果作为第一个参数的变量没有值时，使用第二个参数的值来替代（默认值）。`var(--color, red)`。





### innerText 与 textContent 的区别

`innerText`由于存在诸多特别的特性、以及兼容性差异，以及性能方面问题，以及实际开发的需求的考量，不推荐使用，推荐使用`textContent`获取文本内容。

```
var text = dom.textContent;
```

如果你的项目还需要兼容IE8浏览器，则使用下面的代码：

```
var text = dom.textContent || dom.innerText;
```

[具体差异可以参考这里 🖱](https://m.html.cn/web/javascript/12225.html)





### 使用require.context实现前端工程自动化

`require.context`是一个由**webpack**的api，主要用来实现自动化导入模块，在前端工程中，如果遇到从一个文件夹引入很多模块的情况,可以使用这个api，它会遍历文件夹中的指定文件，然后自动导入，使得不需要每次显式的调用import导入模块。

它包含三个参数：

* 需要检索的目录路径
* 是否递归检索其中的子目录
* 检索目标的匹配正则

```js
// 使用案例
const context = require.context("./modules", true, /\.js$/);
```

上面的`context`就会得到一个包含`modules`目录下所有的`js`文件集合，你可以将该集合格式化成你想要的的格式导出。





### localStorage 和 sessionStorage 的区别

* localStorage 可以一直存储在浏览器中，并且可以被同域的其他进程所共享
* sessionStorage 只存在于当前进程中，并且在当前tab被关闭时清除





### 虚拟DOM的优点

“DOM 操作慢” 这句话是不完全正确的，因为它缺少对比对象。

事实上，DOM操作相比于原生JS操作确实要慢许多，但是一定不代表它会慢于依靠JS编写的虚拟DOM操作，因为虚拟DOM最后还是要依赖原生DOM操作。

虚拟DOM真正的优点是：

1. 减少操作DOM的次数，从而缩短总的资源消耗。比如要更新1000个div，然而实际上只有10个div需要真正得更新，虚拟DOM就可以通过diff算法来找出这10个div，然后一口气让它们更新到页面上；
2. 跨平台渲染





### Vue中props引用类型默认值

在Vue组件中，同`data`一样，如果要为`props`设置一个引用类型的默认值，同样需要以**函数返回值**的形式进行设置。



### Vue-Router 路径碰撞匹配问题

`/a`在Vue-Router的路由匹配中存在两种结果，根路径`/`下的子路径`a`，以及一级路径`/a`。

由于根路径`/`的子路由与一级路径的格式相同，并且当出现根路径`/`的子路径与其它一级路径碰撞时，Vue-Router不会报错，而是会默认匹配根路径`/`的子路径，所以有时候会带来意想不到的BUG。

```js
const routes = [
  {
    path: "/",
    name: "Home",
    component: Home,
    children: [
      {
        path: "/a", // 访问 /a 会被匹配到
        component: About,
      },
    ],
  },
  {
    path: "/a", // 匹配规则同为 /a
    component: Aaa,
  },
]
```

导致这一现象的原因是因为Vue-Router使用一个**路由信息映射表**来存储路径与路由信息的映射关系，在初始化该表时，会判断其中是否已经存在当前路径，如果存在则pass掉后面的操作，简单说就是**不会覆盖前面的信息**，结合初始化操作中含有**递归操作**，会一口气将一个路径包含其子路径全部初始化，所以**书写在上面的路径及其子路径**永远比**其他一级路径**要先于初始化。



### 通过vscode调试Node

调试 —— 添加配置 —— Node.js 启动程序 —— 修改配置文件

```json
"configurations": [
  {
    "type": "node",
    "request": "launch",
    "name": "Launch via NPM",
    "runtimeExecutable": "npm",
    "restart": true,
    "console": "integratedTerminal",
    "runtimeArgs": ["run-script", "dev"],
    "port": 9229
  },
}
```





### concurrently + nodemon + tsc -w 监控TS文件变化

concurrently用于同步执行一些指令：

```json
  "scripts": {
    "dev:build": "tsc -w",
    "dev:start": "nodemon node ./build/crawler.js",
    "dev": "concurrently npm:dev:*"
  },
```

只需跑`npm run dev`即可，`tsc -w`监视TS文件变化，生成新的JS文件，`nodemon`再监视生成的JS文件，这样TS一发生修改，JS文件就会重新执行。



### 语义化版本

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. **主版本号**：当你做了不兼容的 API 修改，
2. **次版本号**：当你做了向下兼容的功能性新增，
3. **修订号**：当你做了向下兼容的问题修正。

**先行版本号**及**版本编译元数据**可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

**先行版本号语义**

* alpha：内测版本，可能会产生大量BUG以及新功能迭代
* beta：公测版本，消除了严重的BUG，但是还是有可能继续投入新的功能
* rc（release candidate）：发行候选版本，不再进行新功能的添加，主要是对现有代码的排错。



### exports 与 module.exports

`exports`是一个指向`module.exports`的变量，因此其实二者指向的是同一个对象。但是在实际编码中，最好还是使用`module.exports`，因为如果直接将`exports`变量指向一个值，就切断了`exports`与`module.exports`的联系，导致意外发生：

```js
// a.js
exports = function a() {};

// b.js
const a = require('./a.js') // a 是一个空对象
```

如果只是想在导出对象身上绑定属性的话，还是可以起到简化语法的作用的。

```js
exports.a = "a"; // 等价于下面
module.exports.a = "a";
```





### 空数组与every()

当空数组调用`every`方法时，默认返回`true`。



### addEventListener传入对象做回调函数参数

`addEventListener`函数的第二个参数不仅可以传回调函数，还支持接收一个对象，如果该参数是一个对象，则会去该对象中寻找名为`handleEvent`的回调函数，测试代码如下：

```js
let Dom = {
  handleEvent: function (event) {
    console.log("hello");
  },
  bind: function () {
    const button = document.querySelector("button");
    // 按钮点击之后打印hello
    button.addEventListener("click", this);
  },
};

Dom.bind();
```



### package-lock的作用

Node工程中的`package-lock.json`文件是用来**锁住依赖包版本**的，npm早期版本直接使用`package.json`控制版本，不过`package.json`只能锁住大版本，后面的小版本每一次都会选择最新的版本，这样就很有可能因为依赖包版本差异的原因带来意想不到的问题。（如：AntDesign圣诞事件）



### 进程与线程

进程是**资源**的最小调度单位，线程是**执行**的最小调度单位。一般来说，我们需要在计算机系统中开辟一段新的资源空间给某一应用时，就需要打开一条进程；而当我们需要使用这些资源去执行某些任务时，最小也需要打开一条线程。



### Vuex中**mutations**存在的意义

- Vuex中**mutations**存在的意义是为了配合`Devtools`来实现对状态变更的监控。



### Vue父子组件的加载顺序为

Vue父子组件的加载顺序为：

```
加载渲染过程
父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted
子组件更新过程
父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated
父组件更新过程
父beforeUpdate -> 父updated
子组件更新过程
子beforeUpdate -> 子updated
父组件销毁过程
父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed
```

其实不难理解，子组件中很可能存在依赖于父组件的`props`或者其他形式的插值，但是只有父组件中所有的子组件内容挂载完毕后父组件才能算是完全挂载完成，所以才有这么一个类似于**洋葱模型**一样的执行顺序。



