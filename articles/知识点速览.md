# 知识点速览

### 通过vscode调试Node

调试 —— 添加配置 —— Node.js 启动程序 —— 修改配置文件

```json
"configurations": [
  {
    "type": "node",
    "request": "launch",
    "name": "Launch via NPM",
    "runtimeExecutable": "npm",
    "restart": true,
    "console": "integratedTerminal",
    "runtimeArgs": ["run-script", "dev"],
    "port": 9229
  },
}
```





### concurrently + nodemon + tsc -w 监控TS文件变化

concurrently用于同步执行一些指令：

```json
  "scripts": {
    "dev:build": "tsc -w",
    "dev:start": "nodemon node ./build/crawler.js",
    "dev": "concurrently npm:dev:*"
  },
```

只需跑`npm run dev`即可，`tsc -w`监视TS文件变化，生成新的JS文件，`nodemon`再监视生成的JS文件，这样TS一发生修改，JS文件就会重新执行。



### 语义化版本

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. **主版本号**：当你做了不兼容的 API 修改，
2. **次版本号**：当你做了向下兼容的功能性新增，
3. **修订号**：当你做了向下兼容的问题修正。

**先行版本号**及**版本编译元数据**可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

**先行版本号语义**

* alpha：内测版本，可能会产生大量BUG以及新功能迭代
* beta：公测版本，消除了严重的BUG，但是还是有可能继续投入新的功能
* rc（release candidate）：发行候选版本，不再进行新功能的添加，主要是对现有代码的排错。



### exports 与 module.exports

`exports`是一个指向`module.exports`的变量，因此其实二者指向的是同一个对象。但是在实际编码中，最好还是使用`module.exports`，因为如果直接将`exports`变量指向一个值，就切断了`exports`与`module.exports`的联系，导致意外发生：

```js
// a.js
exports = function a() {};

// b.js
const a = require('./a.js') // a 是一个空对象
```

如果只是想在导出对象身上绑定属性的话，还是可以起到简化语法的作用的。

```js
exports.a = "a"; // 等价于下面
module.exports.a = "a";
```





### 空数组与every()

当空数组调用`every`方法时，默认返回`true`。



### addEventListener传入对象做回调函数参数

`addEventListener`函数的第二个参数不仅可以传回调函数，还支持接收一个对象，如果该参数是一个对象，则会去该对象中寻找名为`handleEvent`的回调函数，测试代码如下：

```js
let Dom = {
  handleEvent: function (event) {
    console.log("hello");
  },
  bind: function () {
    const button = document.querySelector("button");
    // 按钮点击之后打印hello
    button.addEventListener("click", this);
  },
};

Dom.bind();
```



### package-lock的作用

Node工程中的`package-lock.json`文件是用来**锁住依赖包版本**的，npm早期版本直接使用`package.json`控制版本，不过`package.json`只能锁住大版本，后面的小版本每一次都会选择最新的版本，这样就很有可能因为依赖包版本差异的原因带来意想不到的问题。（如：AntDesign圣诞事件）



### 进程与线程

进程是**资源**的最小调度单位，线程是**执行**的最小调度单位。一般来说，我们需要在计算机系统中开辟一段新的资源空间给某一应用时，就需要打开一条进程；而当我们需要使用这些资源去执行某些任务时，最小也需要打开一条线程。



### Vuex中**mutations**存在的意义

- Vuex中**mutations**存在的意义是为了配合`Devtools`来实现对状态变更的监控。



### Vue父子组件的加载顺序为

Vue父子组件的加载顺序为：

```
加载渲染过程
父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted
子组件更新过程
父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated
父组件更新过程
父beforeUpdate -> 父updated
子组件更新过程
子beforeUpdate -> 子updated
父组件销毁过程
父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed
```

其实不难理解，子组件中很可能存在依赖于父组件的`props`或者其他形式的插值，但是只有父组件中所有的子组件内容挂载完毕后父组件才能算是完全挂载完成，所以才有这么一个类似于**洋葱模型**一样的执行顺序。



