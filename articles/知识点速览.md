# 知识点速览

### CSS伪类hover与伪元素before/after一起用

```CSS
.box:hover:after 
```

伪元素由`::`变为`:`。





### 组件式开发样式编写须知

1. 慎用`scoped`，尽可能在组件最外层包裹**唯一**类名
2. 尽可能得不要在父组件中使用**标签选择器**，很可能会影响到其他子组件





### line-height 对布局的影响

行高会决定`inline`以及`inline-block`等类似行内元素在父元素中的垂直排布位置，如果父元素的行高大于当前行内元素的高度，就会导致子元素的下坠现象，反之亦然，并且这往往**不能通过开发者工具明显的看到**。所以谨慎设置元素的行高，特别是内部很可能会出现行内元素时。





### git 清空工作区和暂存区

1. 还没进行 `add` 和 `commit` 操作：

   ```shell
   git checkout [路径]
   ```

2. 上面只能清空修改的文件，但是对于**新建的文件和文件夹**无法清空，必须使用下面的命令：

   ```shell
   git clean -f
   ```

3. 已经 `add` 了，使用：

   ```
   git reset .
   ```

4. 已经`commit`了，参考下面的`git reset`用法进行回退





### git reset

用于回退至某次提交，分别有三个参数：

* `hard`：清空当前所有区域的修改，完全回到某次提交时 
* `soft`：保留当前的`git add`和工作区未`add`的代码，回到某次提交
* `mixed（default）`：撤销当前的`add`到工作区，保留工作区未`add`的代码，回到某次提交





### 退出 git log

英文状态下按`q`。





### git revert

用一个新的`commit`覆盖原本的`commit`，用于退回某一次提交的操作内容（包括工作区和缓冲区），且被退回内容之后的修改内容不受影响。





### document.documentElement & document.body

在页面中包含`!DOCTYPE`标识时使用前者，否则使用后者。





### 在shell中选择内容

如果这么做，会中止正在执行的脚本。

按`ctrl + c`取消选择可继续执行脚本。





### class——super

* `super`在普通方法中作为对象使用时，表示父类的实例对象
* `super`在静态方法中作为对象使用时，表示父类本身





### MongoDB未查到的返回值

* `findOne`：为`null`，不是空对象
* `find`：是个空数组





### windows 查看端口占用情况

```shell
netstat -ano | findstr "端口号"
```





### TypeScript 中的类型断言 as

- 要理解好类型断言，其实就深刻理解一句话：**你会比TypeScript更了解某个值的详细信息** 。
- 类型断言，断言 断言，顾名思义，我断定怎么怎么样，代入这句话里就是，我断定这个类型是什么。当然这是我们主观上的思维逻辑，程序并不认可，所以我们需要告诉程序：**“相信我，我知道自己在干什么”** 。





### 自定义组件对外开放事件监听

默认情况下，我们是无法在自定义组件上监听事件的，通常我们会通过两种方式来解决：

* 在自定义组件身上使用`@事件.native`来监听原生事件
* 在自定义组件内部对相应事件做监听，并向上传递给父组件

这里提供第三种方法，在自定义组件内部添加`v-on="$listeners"`，将事件监听权限对外开放，这样就可以直接在父组件中对该组件进行事件监听了。





### 箭头函数没有原型

如题，箭头函数没有原型，没有`arguments`，没有`this`，且无法通过其他手段修改`this`，也无法作为构造函数。





### window.top & window.self

分别用来标记最顶层的浏览器窗口和当前的浏览器窗口。

**另外window.top不可覆盖，不能当全局变量使用**。





### Nuxt.js中 asyncData 与 data 的区别

**asyncData** 是在 vue 页面创建期间调用，用于给页面变量进行赋值的数据。

**目前的**理解是，提供了一个**可以通过`async/await`阻塞的组件加载钩子**，它和`beforeCreate`钩子的位置差不多，大概都在组件实例形成之前执行，且都无法访问`this`，但是`beforeCreate`无法通过`async/await`方式阻塞组件加载（如果强行阻塞很可能会导致后面的钩子先于 beforeCreate 执行）。

**实际应用场景**：

* asyncData可以通过阻塞的方式，将异步数据加载完毕后才渲染组件
* 这样做的好处是可以首屏渲染完整的页面，便于SEO
* 缺点也很明显，会延长白屏时间





### CSSStyleDeclaration.setProperty()

- `propertyName` 是一个 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString) ，代表被更改的CSS属性。
- `value`可选，是一个 `DOMString`，含有新的属性值。如果没有指定, 则当作空字符串。
  - 注意: *value* 不能包含 `"!important"` --那个应该使用 *priority* 参数.
- *priority*可选 是一个 [`DOMString`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMString) 允许设置 "important" CSS 优先级。如果没有指定, 则当作空字符串。



和`DOM.style.xxx = xxx `没太大区别，不过该方法可以修改声明的CSS变量。





### CSS变量

CSS原生也支持声明变量：

```CSS
:root {
   /* 通过双横线来声明 */
   --percentage: 0%;
}
```

通过`var(--percentage)`来读取，同时CSS变量也存在作用域，优先级最高的选择器之中的变量优先级最高，因此一般全局变量都声明在`:root`选择器中。

`var()`还有第二个参数，效果为：如果作为第一个参数的变量没有值时，使用第二个参数的值来替代（默认值）。`var(--color, red)`。





### innerText 与 textContent 的区别

`innerText`由于存在诸多特别的特性、以及兼容性差异，以及性能方面问题，以及实际开发的需求的考量，不推荐使用，推荐使用`textContent`获取文本内容。

```
var text = dom.textContent;
```

如果你的项目还需要兼容IE8浏览器，则使用下面的代码：

```
var text = dom.textContent || dom.innerText;
```

[具体差异可以参考这里 🖱](https://m.html.cn/web/javascript/12225.html)





### 使用require.context实现前端工程自动化

`require.context`是一个由**webpack**的api，主要用来实现自动化导入模块，在前端工程中，如果遇到从一个文件夹引入很多模块的情况,可以使用这个api，它会遍历文件夹中的指定文件，然后自动导入，使得不需要每次显式的调用import导入模块。

它包含三个参数：

* 需要检索的目录路径
* 是否递归检索其中的子目录
* 检索目标的匹配正则

```js
// 使用案例
const context = require.context("./modules", true, /\.js$/);
```

上面的`context`就会得到一个包含`modules`目录下所有的`js`文件集合，你可以将该集合格式化成你想要的的格式导出。





### localStorage 和 sessionStorage 的区别

* localStorage 可以一直存储在浏览器中，并且可以被同域的其他进程所共享
* sessionStorage 只存在于当前进程中，并且在当前tab被关闭时清除





### 虚拟DOM的优点

“DOM 操作慢” 这句话是不完全正确的，因为它缺少对比对象。

事实上，DOM操作相比于原生JS操作确实要慢许多，但是一定不代表它会慢于依靠JS编写的虚拟DOM操作，因为虚拟DOM最后还是要依赖原生DOM操作。

虚拟DOM真正的优点是：

1. 减少操作DOM的次数，从而缩短总的资源消耗。比如要更新1000个div，然而实际上只有10个div需要真正得更新，虚拟DOM就可以通过diff算法来找出这10个div，然后一口气让它们更新到页面上；
2. 跨平台渲染





### Vue中props引用类型默认值

在Vue组件中，同`data`一样，如果要为`props`设置一个引用类型的默认值，同样需要以**函数返回值**的形式进行设置。



### Vue-Router 路径碰撞匹配问题

`/a`在Vue-Router的路由匹配中存在两种结果，根路径`/`下的子路径`a`，以及一级路径`/a`。

由于根路径`/`的子路由与一级路径的格式相同，并且当出现根路径`/`的子路径与其它一级路径碰撞时，Vue-Router不会报错，而是会默认匹配根路径`/`的子路径，所以有时候会带来意想不到的BUG。

```js
const routes = [
  {
    path: "/",
    name: "Home",
    component: Home,
    children: [
      {
        path: "/a", // 访问 /a 会被匹配到
        component: About,
      },
    ],
  },
  {
    path: "/a", // 匹配规则同为 /a
    component: Aaa,
  },
]
```

导致这一现象的原因是因为Vue-Router使用一个**路由信息映射表**来存储路径与路由信息的映射关系，在初始化该表时，会判断其中是否已经存在当前路径，如果存在则pass掉后面的操作，简单说就是**不会覆盖前面的信息**，结合初始化操作中含有**递归操作**，会一口气将一个路径包含其子路径全部初始化，所以**书写在上面的路径及其子路径**永远比**其他一级路径**要先于初始化。



### 通过vscode调试Node

调试 —— 添加配置 —— Node.js 启动程序 —— 修改配置文件

```json
"configurations": [
  {
    "type": "node",
    "request": "launch",
    "name": "Launch via NPM",
    "runtimeExecutable": "npm",
    "restart": true,
    "console": "integratedTerminal",
    "runtimeArgs": ["run-script", "dev"],
    "port": 9229
  },
}
```





### concurrently + nodemon + tsc -w 监控TS文件变化

concurrently用于同步执行一些指令：

```json
  "scripts": {
    "dev:build": "tsc -w",
    "dev:start": "nodemon node ./build/crawler.js",
    "dev": "concurrently npm:dev:*"
  },
```

只需跑`npm run dev`即可，`tsc -w`监视TS文件变化，生成新的JS文件，`nodemon`再监视生成的JS文件，这样TS一发生修改，JS文件就会重新执行。



### 语义化版本

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. **主版本号**：当你做了不兼容的 API 修改，
2. **次版本号**：当你做了向下兼容的功能性新增，
3. **修订号**：当你做了向下兼容的问题修正。

**先行版本号**及**版本编译元数据**可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

**先行版本号语义**

* alpha：内测版本，可能会产生大量BUG以及新功能迭代
* beta：公测版本，消除了严重的BUG，但是还是有可能继续投入新的功能
* rc（release candidate）：发行候选版本，不再进行新功能的添加，主要是对现有代码的排错。



### exports 与 module.exports

`exports`是一个指向`module.exports`的变量，因此其实二者指向的是同一个对象。但是在实际编码中，最好还是使用`module.exports`，因为如果直接将`exports`变量指向一个值，就切断了`exports`与`module.exports`的联系，导致意外发生：

```js
// a.js
exports = function a() {};

// b.js
const a = require('./a.js') // a 是一个空对象
```

如果只是想在导出对象身上绑定属性的话，还是可以起到简化语法的作用的。

```js
exports.a = "a"; // 等价于下面
module.exports.a = "a";
```





### 空数组与every()

当空数组调用`every`方法时，默认返回`true`。



### addEventListener传入对象做回调函数参数

`addEventListener`函数的第二个参数不仅可以传回调函数，还支持接收一个对象，如果该参数是一个对象，则会去该对象中寻找名为`handleEvent`的回调函数，测试代码如下：

```js
let Dom = {
  handleEvent: function (event) {
    console.log("hello");
  },
  bind: function () {
    const button = document.querySelector("button");
    // 按钮点击之后打印hello
    button.addEventListener("click", this);
  },
};

Dom.bind();
```



### package-lock的作用

Node工程中的`package-lock.json`文件是用来**锁住依赖包版本**的，npm早期版本直接使用`package.json`控制版本，不过`package.json`只能锁住大版本，后面的小版本每一次都会选择最新的版本，这样就很有可能因为依赖包版本差异的原因带来意想不到的问题。（如：AntDesign圣诞事件）



### 进程与线程

进程是**资源**的最小调度单位，线程是**执行**的最小调度单位。一般来说，我们需要在计算机系统中开辟一段新的资源空间给某一应用时，就需要打开一条进程；而当我们需要使用这些资源去执行某些任务时，最小也需要打开一条线程。



### Vuex中**mutations**存在的意义

- Vuex中**mutations**存在的意义是为了配合`Devtools`来实现对状态变更的监控。



### Vue父子组件的加载顺序为

Vue父子组件的加载顺序为：

```
加载渲染过程
父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted
子组件更新过程
父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated
父组件更新过程
父beforeUpdate -> 父updated
子组件更新过程
子beforeUpdate -> 子updated
父组件销毁过程
父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed
```

其实不难理解，子组件中很可能存在依赖于父组件的`props`或者其他形式的插值，但是只有父组件中所有的子组件内容挂载完毕后父组件才能算是完全挂载完成，所以才有这么一个类似于**洋葱模型**一样的执行顺序。



