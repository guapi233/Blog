# 知识点速览

### Vue-Router 路径碰撞匹配问题

`/a`在Vue-Router的路由匹配中存在两种结果，根路径`/`下的子路径`a`，以及一级路径`/a`。

由于根路径`/`的子路由与一级路径的格式相同，并且当出现根路径`/`的子路径与其它一级路径碰撞时，Vue-Router不会报错，而是会默认匹配根路径`/`的子路径，所以有时候会带来意想不到的BUG。

```js
const routes = [
  {
    path: "/",
    name: "Home",
    component: Home,
    children: [
      {
        path: "/a", // 访问 /a 会被匹配到
        component: About,
      },
    ],
  },
  {
    path: "/a", // 匹配规则同为 /a
    component: Aaa,
  },
]
```

导致这一现象的原因是因为Vue-Router使用一个**路由信息映射表**来存储路径与路由信息的映射关系，在初始化该表时，会判断其中是否已经存在当前路径，如果存在则pass掉后面的操作，简单说就是**不会覆盖前面的信息**，结合初始化操作中含有**递归操作**，会一口气将一个路径包含其子路径全部初始化，所以**书写在上面的路径及其子路径**永远比**其他一级路径**要先于初始化。



### 通过vscode调试Node

调试 —— 添加配置 —— Node.js 启动程序 —— 修改配置文件

```json
"configurations": [
  {
    "type": "node",
    "request": "launch",
    "name": "Launch via NPM",
    "runtimeExecutable": "npm",
    "restart": true,
    "console": "integratedTerminal",
    "runtimeArgs": ["run-script", "dev"],
    "port": 9229
  },
}
```





### concurrently + nodemon + tsc -w 监控TS文件变化

concurrently用于同步执行一些指令：

```json
  "scripts": {
    "dev:build": "tsc -w",
    "dev:start": "nodemon node ./build/crawler.js",
    "dev": "concurrently npm:dev:*"
  },
```

只需跑`npm run dev`即可，`tsc -w`监视TS文件变化，生成新的JS文件，`nodemon`再监视生成的JS文件，这样TS一发生修改，JS文件就会重新执行。



### 语义化版本

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. **主版本号**：当你做了不兼容的 API 修改，
2. **次版本号**：当你做了向下兼容的功能性新增，
3. **修订号**：当你做了向下兼容的问题修正。

**先行版本号**及**版本编译元数据**可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

**先行版本号语义**

* alpha：内测版本，可能会产生大量BUG以及新功能迭代
* beta：公测版本，消除了严重的BUG，但是还是有可能继续投入新的功能
* rc（release candidate）：发行候选版本，不再进行新功能的添加，主要是对现有代码的排错。



### exports 与 module.exports

`exports`是一个指向`module.exports`的变量，因此其实二者指向的是同一个对象。但是在实际编码中，最好还是使用`module.exports`，因为如果直接将`exports`变量指向一个值，就切断了`exports`与`module.exports`的联系，导致意外发生：

```js
// a.js
exports = function a() {};

// b.js
const a = require('./a.js') // a 是一个空对象
```

如果只是想在导出对象身上绑定属性的话，还是可以起到简化语法的作用的。

```js
exports.a = "a"; // 等价于下面
module.exports.a = "a";
```





### 空数组与every()

当空数组调用`every`方法时，默认返回`true`。



### addEventListener传入对象做回调函数参数

`addEventListener`函数的第二个参数不仅可以传回调函数，还支持接收一个对象，如果该参数是一个对象，则会去该对象中寻找名为`handleEvent`的回调函数，测试代码如下：

```js
let Dom = {
  handleEvent: function (event) {
    console.log("hello");
  },
  bind: function () {
    const button = document.querySelector("button");
    // 按钮点击之后打印hello
    button.addEventListener("click", this);
  },
};

Dom.bind();
```



### package-lock的作用

Node工程中的`package-lock.json`文件是用来**锁住依赖包版本**的，npm早期版本直接使用`package.json`控制版本，不过`package.json`只能锁住大版本，后面的小版本每一次都会选择最新的版本，这样就很有可能因为依赖包版本差异的原因带来意想不到的问题。（如：AntDesign圣诞事件）



### 进程与线程

进程是**资源**的最小调度单位，线程是**执行**的最小调度单位。一般来说，我们需要在计算机系统中开辟一段新的资源空间给某一应用时，就需要打开一条进程；而当我们需要使用这些资源去执行某些任务时，最小也需要打开一条线程。



### Vuex中**mutations**存在的意义

- Vuex中**mutations**存在的意义是为了配合`Devtools`来实现对状态变更的监控。



### Vue父子组件的加载顺序为

Vue父子组件的加载顺序为：

```
加载渲染过程
父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted
子组件更新过程
父beforeUpdate -> 子beforeUpdate -> 子updated -> 父updated
父组件更新过程
父beforeUpdate -> 父updated
子组件更新过程
子beforeUpdate -> 子updated
父组件销毁过程
父beforeDestroy -> 子beforeDestroy -> 子destroyed -> 父destroyed
```

其实不难理解，子组件中很可能存在依赖于父组件的`props`或者其他形式的插值，但是只有父组件中所有的子组件内容挂载完毕后父组件才能算是完全挂载完成，所以才有这么一个类似于**洋葱模型**一样的执行顺序。



