# 防抖节流

老伙计了，做个人项目时好多地方需要用到，正好发现自己还没有整理出一篇文章，就想着产出一篇笔记来。防抖和节流网上都讲烂了，这里就直接上干货了。



## 防抖

防抖的意思是规定**两次操作之间的间隔**，如果两次操作的时间间隔小于指定的时间，则判定第二次操作无效。翻译成大白话就是：“让你歇一秒再操作，你非要搁那一直点个不停，那劳资就判你这些操作都无效，什么时候停下来歇完一秒后才算数”。



### 示例代码

```js
const debounce = (fn, time, immediate) => {
  let timer = null;

  // 包裹函数
  const bundler = (...arg) => {
    // 是否开启立即执行
    if (immediate) {
      // 开启立即执行后为下文条目3的执行逻辑
      clearTimeout(timer);
      let flag = !timer;
      if (flag) fn(...arg);

      timer = setTimeout(() => {
        timer = null;
        // 如果想隔阂时间结束后同样执行方法，像这样在这里执行下方法即可
        fn(...arg);
      }, time);
    } else {
       // 不开启立即执行后为下文条目1的执行逻辑
      clearTimeout(timer);
      timer = setTimeout(() => {
        fn(...arg);
      }, time);
    }
  };

  // 取消本次时间隔阂
  bundler.cancel = () => {
    clearTimeout(timer);
    timer = null;
  };

  return bundler;
};
```





### 实现原理

笔者的语文功底很弱，所以下面的话一定要看着代码来进行阅读：

1. 通过**定时器**延时操作需要执行的函数，并在方法最顶部清除定时器，这就导致，如果方法触发的时间小于定时器指定的时间，定时器就会在执行之前立马被关闭掉，里面的方法执行不了，本次的操作也就算做无效了。
2. 以前实现防抖和节流还要想办法去拿被加工函数的**参数**和`this`，比如通过`arguments`和`call`等，现在直接通过**拓展运算符**和**箭头函数**就可以了。
3. 条目`1`中提到的防抖函数每次都会在时间隔阂结束之后执行方法，如果想在触发时先立马触发一次方法，可以在防抖函数中每次判断保存定时器的变量，并在定时器中将该变量置为`null`，同时也要在防抖函数顶部清除定时器，这样，第一次进如防抖函数时，因为该变量默认为`null`，所以会立马执行一次，接下来由于变量中存储了定时器，如果不到规定时间执行定时器中的置`null`操作，变量会一直不变为`null`，这样这些操作都算是无效操作。如果想要在立即执行的前提下，在时间隔阂之后也执行一次方法，只需要在定时器中加入函数执行语句即可。
4. 取消本次隔阂时间：这个操作也很简单，由于防抖函数使用了柯里化函数，可以在内部返回函数的身上添加`cancel`方法，在该方法中关闭定时器，同时将`timer`置为`null`即可。



